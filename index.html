<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数学で動かすロボットシミュレーション</title>
    <link rel="stylesheet" href="main.css">
</head>

<body>

    <div class="container">
        <div class="left-spacer"></div>

        <main>
            <h1>【JavaScript】数学で動かすロボットシミュレーション</h1>

            <section id="overview">
                <h2>1. 概要</h2>
                <p>
                    ロボット自動制御で用いられる経路追従アルゴリズム「Pure
                    Pursuit法」のシミュレーションをjsを使用して行う。JavaScriptの<strong>計算処理能力</strong>と<strong>リアルタイム描画能力</strong>を駆使することで、簡単なシミュレーションを示すことができる。
                </p>
                <img src="diagram.png" alt="Pure Pursuitアルゴリズムの解説図" class="content-image">
            </section>

            <section id="simulation-area">
                <h2>2. 製作物：Pure Pursuit法シミュレーション</h2>
                <p>
                    4輪オムニホイールのロボットが、指定された経路を自動で追いかける様子をシミュレートしたものである。ロボットの動きや、各ホイールの回転（青い矢印）がリアルタイムに計算され、描画される。
                </p>
                <div id="simulation-wrapper">
                    <div id="instructions">
                        <p>操作方法:キャンバス内をクリックして経路を作成し、「Start」ボタンを押すと開始し「Reset」ボタンを押すと初期位置に戻る。<br>
                            また、最初の経由点がロボットと離れていたり、経由点が離散していると予期せぬ動作をする場合がある。
                        </p>
                    </div>
                    <canvas id="simulationCanvas" width="700" height="500"></canvas>
                    <div id="controls">
                        <button id="startButton">Start</button>
                        <button id="resetButton">Reset</button>
                    </div>
                </div>
            </section>

            <section id="code-explanation">
                <h2>3. 今回使用したJavaScript技術</h2>
                <p>
                    このシミュレーションは、主に3つのJavaScript技術要素で構成されている。
                </p>
                <h3>技術①：Canvas APIによるリアルタイム描画</h3>
                <p>
                    ウェブページで要素を動かすというと「DOM操作」が一般的だが、このデモでは<code>&lt;canvas&gt;</code>要素を使っている。DOMがHTML要素をオブジェクトとして扱うのに対し、Canvasはピクセル単位で図形を描画するための画用紙のようなものである。これにより、毎フレーム変化するロボットの位置や角度、デバッグ用の円や矢印といった、<strong>自由で動的なグラフィックス表現</strong>が可能である。
                </p>
                <p>
                    また、アニメーションには<code>requestAnimationFrame</code>を用いている。これはブラウザの描画サイクルと同期するため、<code>setInterval</code>などと比べて、より滑らかでパフォーマンスに優れたアニメーションを実現する現代的な手法である。
                </p>
                <pre><code>// 毎フレーム呼び出される描画ループ
function animate() {
    // 1. ロボットの位置や角度を計算
    const result = purePursuit();
    robot.update(result.control.vx, result.control.vy, result.control.omega);

    // 2. Canvasをクリアし、すべてを描画し直す
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawPath();
    robot.draw();
    drawDebugInfo(result.debug);

    // 3. 次の描画フレームを予約
    animationFrameId = requestAnimationFrame(animate);
}</code></pre>

                <h3>技術②：三角関数とベクトル演算による計算処理</h3>
                <p>
                    このシミュレーションの心臓部は、<strong>数学</strong>である。ロボットの滑らかな動きは、三角関数やベクトルといった計算処理によって実現されている。
                </p>
                <ul>
                    <li><strong>座標変換：</strong>ロボットの向き（角度）に応じて、ロボットから見た前後左右の速度を、<code>Math.sin()</code> と
                        <code>Math.cos()</code> を使って画面全体から見た速度ベクトルに変換している。
                    </li>
                    <li><strong>目標点探索：</strong>ロボットと経路との距離を三平方の定理（<code>Math.hypot()</code>）で計算し、追従すべき目標点を見つけ出している。</li>
                    <li><strong>ベクトルの内積：</strong>目標点が複数見つかった場合に、ロボットの「前方」にある点を正しく選択するため、ベクトルの内積を計算し、その符号（正か負か）を利用している。
                    </li>
                </ul>
                <p>
                    このように、JavaScriptに標準で備わっている<code>Math</code>オブジェクトを活用するだけで、物理法則に基づいた複雑なシミュレーションを構築できる。
                </p>

                <h3>技術③：ES6 Classesによるオブジェクト指向設計</h3>
                <p>
                    コードを整理し、メンテナンス性を高めるために、ES6で導入された<code>class</code>構文を利用している。ロボットに関するデータ（位置、角度、半径など）と、その振る舞い（更新、描画など）を<code>OmniRobot</code>という一つのクラスにまとめている。
                </p>
                <p>
                    このように関連する処理をひとまとめにする（カプセル化）ことで、コードの見通しが良くなり、他の部分から独立した「部品」として扱えるようになる。これは、大規模なアプリケーションを開発する上で非常に重要な考え方である。
                </p>
                <pre><code>class OmniRobot {
    // データ（プロパティ）
    constructor(x, y, angle = 0) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        // ...
    }

    // 振る舞い（メソッド）
    update(vx, vy, omega) { /* ... 位置や角度を更新する計算 ... */ }
    draw() { /* ... 自分自身をCanvasに描画する処理 ... */ }
}

// クラスから実体（インスタンス）を作成
const robot = new OmniRobot(100, 100, 0);</code></pre>

            </section>

            <section id="appendix">
                <h2>4. おまけ：なぜ並進と回転を独立して制御するのか？</h2>
                <p>
                    このシミュレーションをよく見ると、ロボットは目標点に向かって進む動き（並進）と、体の向きを経路に合わせる動き（回転）を同時に行っている。全方向に移動できるのに、なぜわざわざ向きを変えるのか？と疑問に思うかもしれない。
                </p>
                <p>
                    これこそが、このオムニロボットが持つ<strong>「ホロノミック（holonomic）」</strong>という特性を活かした高度な制御方法の現れである。自動車と違い、このロボットは「移動方向」と「体の向き」を完全に分離して制御できる。
                </p>
                <img src="photo.jpg" alt="オムニホイールロボットの写真" class="content-image">
                <ul>
                    <li><strong>並進制御：</strong>「経路から外れない」というタスクに専念し、最短で目標点に向かう。</li>
                    <li><strong>回転制御：</strong>「体の正面を経路に向ける」という別のタスクに専念する。</li>
                </ul>
                <p>
                    このおかげで、例えばロボットの正面にカメラが付いている場合、常に進行方向を撮影しながら、経路追従のための細かな横移動も同時に行う、といった器用な動作が可能になる。
                    <br>
                    製作時間：約9時間
                </p>
            </section>
        </main>

        <aside>
            <div class="toc">
                <h3>目次</h3>
                <ul>
                    <li><a href="#overview">1. 概要</a></li>
                    <li><a href="#simulation-area">2. 製作物：Pure Pursuit法シミュレーション</a></li>
                    <li><a href="#code-explanation">3. 今回使用したJavaScript技術</a></li>
                    <li><a href="#appendix">4. おまけ：なぜ並進と回転を独立して制御するのか？</a></li>
                </ul>
            </div>
        </aside>

    </div>

    <script src="main.js"></script>
</body>

</html>